import { __assign } from "tslib";
import path from 'path';
import remarkMdx from 'remark-mdx';
import remarkParse from 'remark-parse';
import unified from 'unified';
import { hasProperties, isJsxNode, last, normalizeParser, normalizePosition, restoreNodeLocation, } from './helper';
import { COMMENT_CONTENT_REGEX, isComment } from './regexp';
import { traverse } from './traverse';
export var mdxProcessor = unified()
    .use(remarkParse)
    .use(remarkMdx)
    .freeze();
export var AST_PROPS = ['body', 'comments', 'tokens'];
export var ES_NODE_TYPES = ['export', 'import', 'jsx'];
export var LOC_ERROR_PROPERTIES = ['column', 'index', 'lineNumber'];
export var DEFAULT_EXTENSIONS = ['.mdx'];
export var MARKDOWN_EXTENSIONS = ['.md'];
export var DEFAULT_PARSER_OPTIONS = {
    comment: true,
    ecmaFeatures: {
        jsx: true,
    },
    ecmaVersion: new Date().getUTCFullYear(),
    sourceType: 'module',
    tokens: true,
    filePath: '__placeholder__.mdx',
};
var JSX_WRAPPER_START = '<$>';
var JSX_WRAPPER_END = '</$>';
var OFFSET = JSX_WRAPPER_START.length;
var Parser = /** @class */ (function () {
    function Parser() {
        // @internal
        this._options = DEFAULT_PARSER_OPTIONS;
        this.parse = this.parse.bind(this);
        this.parseForESLint = this.parseForESLint.bind(this);
    }
    Parser.prototype.normalizeJsxNode = function (node, parent, options) {
        if (options === void 0) { options = this._options; }
        var value = node.value;
        if (node.type !== 'jsx' || isComment(value)) {
            return node;
        }
        var commentContent = COMMENT_CONTENT_REGEX.exec(value);
        if (commentContent) {
            var comments_1 = [];
            var _a = node.position.start, line_1 = _a.line, column_1 = _a.column, startOffset_1 = _a.offset;
            Object.assign(node, {
                data: __assign(__assign({}, node.data), { jsxType: 'JSXElementWithHTMLComments', comments: comments_1, 
                    // jsx in paragraph is considered as plain html in mdx, what means html style comments are valid
                    // TODO: in this case, jsx style comments could be a mistake
                    inline: !!parent && parent.type !== 'root' }),
                value: value.replace(COMMENT_CONTENT_REGEX, function (matched, $0, $1, $2, offset) {
                    var endOffset = offset + matched.length;
                    var startLines = value.slice(0, offset).split('\n');
                    var endLines = value.slice(0, endOffset).split('\n');
                    var fixed = "{/" + '*'.repeat($0.length - 2) + $1 + '*'.repeat($2.length - 2) + "/}";
                    var startLineOffset = startLines.length - 1;
                    var endLineOffset = endLines.length - 1;
                    comments_1.push({
                        fixed: fixed,
                        // ! eslint ast column is 0-indexed, but unified is 1-indexed
                        loc: {
                            start: {
                                line: line_1 + startLineOffset,
                                column: last(startLines).length +
                                    (startLineOffset ? 0 : column_1 - 1),
                                offset: startOffset_1 + offset,
                            },
                            end: {
                                line: line_1 + endLineOffset,
                                column: last(endLines).length + (endLineOffset ? 0 : column_1 - 1),
                                offset: startOffset_1 + endOffset,
                            },
                        },
                        origin: matched,
                    });
                    return fixed;
                }),
            });
        }
        return this._normalizeJsxNodes(node, options);
    };
    Parser.prototype.parse = function (code, options) {
        return this.parseForESLint(code, options).ast;
    };
    Parser.prototype.parseForESLint = function (code, options) {
        var _this = this;
        var extname = path.extname(options.filePath);
        var isMdx = DEFAULT_EXTENSIONS.concat(options.extensions || []).includes(extname);
        var isMarkdown = MARKDOWN_EXTENSIONS.concat(options.markdownExtensions || []).includes(extname);
        if (!isMdx && !isMarkdown) {
            return this._eslintParse(code, options);
        }
        var root = mdxProcessor.parse(code);
        this._ast = __assign(__assign({}, normalizePosition(root.position)), { type: 'Program', sourceType: options.sourceType || 'module', body: [], comments: [], tokens: [] });
        this._services = {
            JSXElementsWithHTMLComments: [],
        };
        if (isMdx) {
            traverse(root, {
                enter: function (node, parent) {
                    if (!ES_NODE_TYPES.includes(node.type)) {
                        return;
                    }
                    var normalized = _this.normalizeJsxNode(node, parent, options);
                    normalized = Array.isArray(normalized) ? normalized : [normalized];
                    normalized.forEach(function (_node) { return _this._nodeToAst(_node, options); });
                },
            });
        }
        return {
            ast: this._ast,
            services: this._services,
        };
    };
    // @internal
    Parser.prototype._eslintParse = function (code, options) {
        if (!this._parsers || options.parser !== this._options.parser) {
            this._parsers = normalizeParser(options.parser);
        }
        /* istanbul ignore else */
        if (options.filePath && this._options !== options) {
            Object.assign(this._options, options);
        }
        var program;
        var parseError;
        for (var _i = 0, _a = this._parsers; _i < _a.length; _i++) {
            var parser_1 = _a[_i];
            try {
                program = parser_1(code, this._options);
                break;
            }
            catch (e) {
                if (!parseError) {
                    parseError = e;
                }
            }
        }
        if (!program && parseError) {
            throw parseError;
        }
        /* istanbul ignore next */
        return ('ast' in program && program.ast
            ? program
            : { ast: program });
    };
    // fix adjacent JSX nodes
    // @internal
    // eslint-disable-next-line sonarjs/cognitive-complexity
    Parser.prototype._normalizeJsxNodes = function (node, options) {
        var value = node.value;
        var program;
        try {
            // wrap into single element which is valid jsx but not valid jsx in mdx, so that it won't break on adjacent JSX nodes
            program = this._eslintParse("" + JSX_WRAPPER_START + value + JSX_WRAPPER_END, options).ast;
        }
        catch (e) {
            if (hasProperties(e, LOC_ERROR_PROPERTIES)) {
                var start = node.position.start;
                e.index += start.offset - OFFSET;
                e.column =
                    /* istanbul ignore next */
                    e.lineNumber > 1 ? e.column : e.column + start.column - OFFSET;
                e.lineNumber += start.line - 1;
                throw e;
            }
            return node;
        }
        var expression = program
            .body[0].expression;
        if (!isJsxNode(expression) || expression.children.length <= 1) {
            return node;
        }
        var _a = node.position.start, line = _a.line, offset = _a.offset;
        return expression.children.reduce(function (nodes, jsNode) {
            if (!isJsxNode(jsNode)) {
                return nodes;
            }
            var nodeStart = jsNode.start, nodeEnd = jsNode.end, 
            /* istanbul ignore next */
            _a = jsNode.loc, 
            /* istanbul ignore next */
            _b = _a === void 0 ? {
                start: { column: nodeStart, line: 1 },
                end: { column: nodeEnd, line: 1 },
            } : _a, start = _b.start, end = _b.end, 
            /* istanbul ignore next */
            _c = jsNode.range, 
            /* istanbul ignore next */
            range = _c === void 0 ? [nodeStart, nodeEnd] : _c;
            var startLine = line + start.line - 1;
            var endLine = line + end.line - 1;
            var startOffset = range[0] - OFFSET;
            var endOffset = range[1] - OFFSET;
            nodes.push({
                type: 'jsx',
                data: nodes.length ? null : node.data,
                value: value.slice(startOffset, endOffset),
                position: {
                    start: {
                        line: startLine,
                        column: line === startLine ? start.column - OFFSET : start.column,
                        offset: offset + startOffset,
                    },
                    end: {
                        line: endLine,
                        column: line === startLine ? end.column - OFFSET : end.column,
                        offset: offset + endOffset,
                    },
                },
            });
            return nodes;
        }, []);
    };
    // @internal
    Parser.prototype._nodeToAst = function (node, options) {
        var _this = this;
        if (node.data && node.data.jsxType === 'JSXElementWithHTMLComments') {
            this._services.JSXElementsWithHTMLComments.push(node);
        }
        var value = node.value;
        // fix #4
        if (isComment(value)) {
            return;
        }
        var _a = normalizePosition(node.position), loc = _a.loc, start = _a.start;
        var startLine = loc.start.line - 1; // ! line is 1-indexed, change to 0-indexed to simplify usage
        var program;
        try {
            program = this._eslintParse(value, options).ast;
        }
        catch (e) {
            /* istanbul ignore if */
            if (hasProperties(e, LOC_ERROR_PROPERTIES)) {
                // should be handled by `_normalizeJsxNodes`, just for robustness
                e.index += start;
                e.column = e.lineNumber > 1 ? e.column : e.column + loc.start.column;
                e.lineNumber += startLine;
            }
            throw e;
        }
        var offset = start - program.range[0];
        AST_PROPS.forEach(function (prop) {
            var _a;
            return (_a = _this._ast[prop]).push.apply(_a, program[prop].map(function (item) {
                return restoreNodeLocation(item, startLine, offset);
            }));
        });
    };
    return Parser;
}());
export { Parser };
export var parser = new Parser();
export var parse = parser.parse, parseForESLint = parser.parseForESLint;
//# sourceMappingURL=parser.js.map