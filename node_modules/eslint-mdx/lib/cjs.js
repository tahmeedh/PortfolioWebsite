'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var espree = require('espree');
var path = _interopDefault(require('path'));
var remarkMdx = _interopDefault(require('remark-mdx'));
var remarkParse = _interopDefault(require('remark-parse'));
var unified = _interopDefault(require('unified'));

/// <reference path="../typings.d.ts" />
var FALLBACK_PARSERS = [
    '@typescript-eslint/parser',
    'babel-eslint',
];
var JSX_TYPES = ['JSXElement', 'JSXFragment'];
var isJsxNode = function (node) {
    return JSX_TYPES.includes(node.type);
};
// eslint-disable-next-line sonarjs/cognitive-complexity
var normalizeParser = function (parser) {
    if (parser) {
        if (typeof parser === 'string') {
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            parser = require(parser);
        }
        if (typeof parser === 'object') {
            parser =
                ('parseForESLint' in parser && parser.parseForESLint) ||
                    ('parse' in parser && parser.parse);
        }
        if (typeof parser !== 'function') {
            throw new TypeError("Invalid custom parser for `eslint-mdx`: " + parser);
        }
        return [parser];
    }
    var parsers = [espree.parse];
    // try to load FALLBACK_PARSERS automatically
    for (var _i = 0, FALLBACK_PARSERS_1 = FALLBACK_PARSERS; _i < FALLBACK_PARSERS_1.length; _i++) {
        var fallback = FALLBACK_PARSERS_1[_i];
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires
            var fallbackParser = require(fallback);
            /* istanbul ignore next */
            var parserFn = 'parseForESLint' in fallbackParser
                ? fallbackParser.parseForESLint
                : fallbackParser.parse;
            /* istanbul ignore else */
            if (parserFn) {
                parsers.unshift(parserFn);
            }
            break;
        }
        catch (e) { }
    }
    return parsers;
};
var normalizePosition = function (position) {
    var start = position.start.offset;
    var end = position.end.offset;
    return {
        range: [start, end],
        loc: tslib.__assign({}, position),
        start: start,
        end: end,
    };
};
function restoreNodeLocation(node, startLine, offset) {
    if (!node || !node.loc || !node.range) {
        return node;
    }
    Object.entries(node).forEach(function (_a) {
        var key = _a[0], value = _a[1];
        if (!value) {
            return;
        }
        if (Array.isArray(value)) {
            node[key] = value.map(function (child) { return restoreNodeLocation(child, startLine, offset); });
        }
        else {
            node[key] = restoreNodeLocation(value, startLine, offset);
        }
    });
    var _a = node.loc, startLoc = _a.start, endLoc = _a.end, range = node.range;
    var start = range[0] + offset;
    var end = range[1] + offset;
    return tslib.__assign(tslib.__assign({}, node), { start: start,
        end: end, range: [start, end], loc: {
            start: {
                line: startLine + startLoc.line,
                column: startLoc.column,
            },
            end: {
                line: startLine + endLoc.line,
                column: endLoc.column,
            },
        } });
}
var first = function (items) { return items && items[0]; };
var last = function (items) {
    return items && items[items.length - 1];
};
var hasProperties = function (obj, properties) { return properties.every(function (property) { return property in obj; }); };

// based on https://github.com/mdx-js/mdx/blob/master/packages/remark-mdx/tag.js
var dotAllPolyfill = '[\0-\uFFFF]';
var attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var unquoted = '[^"\'=<>`\\u0000-\\u0020]+';
var singleQuoted = "'[^']*'";
var doubleQuoted = '"[^"]*"';
var jsProps = '{.*}'.replace('.', dotAllPolyfill);
var attributeValue = '(?:' +
    unquoted +
    '|' +
    singleQuoted +
    '|' +
    doubleQuoted +
    '|' +
    jsProps +
    ')';
var attribute = '(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
var openTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*>';
var closeTag = '<\\s*\\/[A-Za-z]*[A-Za-z0-9\\.\\-]*\\s*>';
var selfClosingTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*\\/?>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var commentOpen = '(<!---*)';
var commentClose = '(-*-->)';
var OPEN_TAG_REGEX = new RegExp("^(?:" + openTag + ")$");
var CLOSE_TAG_REGEX = new RegExp("^(?:" + closeTag + ")$");
var OPEN_CLOSE_TAG_REGEX = new RegExp("^(?:" + (openTag + '[\\s\\S]*' + closeTag) + ")$");
var SELF_CLOSING_TAG_REGEX = new RegExp("^(?:" + selfClosingTag + ")$");
var COMMENT_REGEX = new RegExp("^(?:" + comment + ")$");
var COMMENT_CONTENT_REGEX = new RegExp(commentOpen + "([\\s\\S]*?)" + commentClose, 'g');
var isOpenTag = function (text) { return OPEN_TAG_REGEX.test(text); };
var isCloseTag = function (text) { return CLOSE_TAG_REGEX.test(text); };
var isComment = function (text) { return COMMENT_REGEX.test(text); };
// the following functions are only declared for robustness and should never be called
/* istanbul ignore next */
var isOpenCloseTag = function (text) { return OPEN_CLOSE_TAG_REGEX.test(text); };
// prettier-ignore
/* istanbul ignore next */
var isSelfClosingTag = function (text) { return SELF_CLOSING_TAG_REGEX.test(text); };

var Traverse = /** @class */ (function () {
    function Traverse(_a) {
        var enter = _a.enter;
        this._enter = enter;
    }
    Traverse.prototype.combineLeftJsxNodes = function (jsxNodes) {
        return {
            type: 'jsx',
            data: jsxNodes[0].data,
            value: jsxNodes.reduce(function (acc, _a) {
                var value = _a.value;
                return (acc += value);
            }, ''),
            position: {
                start: jsxNodes[0].position.start,
                end: last(jsxNodes).position.end,
            },
        };
    };
    // fix #7
    Traverse.prototype.combineJsxNodes = function (nodes) {
        var _this = this;
        var offset = 0;
        var jsxNodes = [];
        var length = nodes.length;
        // eslint-disable-next-line sonarjs/cognitive-complexity
        return nodes.reduce(function (acc, node, index) {
            if (node.type === 'jsx') {
                var value = node.value;
                if (isOpenTag(value)) {
                    offset++;
                    jsxNodes.push(node);
                }
                else {
                    if (isCloseTag(value)) {
                        offset--;
                    }
                    // prettier-ignore
                    /* istanbul ignore next */
                    else if (!isComment(value) &&
                        !isSelfClosingTag(value) &&
                        !isOpenCloseTag(value)) {
                        // should never happen, just for robustness
                        var start = node.position.start;
                        throw Object.assign(new SyntaxError('unknown jsx node: ' + JSON.stringify(value)), {
                            lineNumber: start.line,
                            column: start.column,
                            index: start.offset,
                        });
                    }
                    jsxNodes.push(node);
                    if (!offset) {
                        acc.push(_this.combineLeftJsxNodes(jsxNodes));
                        jsxNodes.length = 0;
                    }
                }
            }
            else if (offset) {
                jsxNodes.push(node);
            }
            else {
                acc.push(node);
            }
            if (index === length - 1 && jsxNodes.length) {
                acc.push(_this.combineLeftJsxNodes(jsxNodes));
            }
            return acc;
        }, []);
    };
    Traverse.prototype.traverse = function (node, parent) {
        var _this = this;
        /* istanbul ignore if */
        if (!node) {
            // should never happen, just for robustness
            return;
        }
        var children = node.children;
        if (children) {
            children = node.children = this.combineJsxNodes(children);
            children.forEach(function (child) { return _this.traverse(child, node); });
        }
        this._enter(node, parent);
    };
    return Traverse;
}());
var traverse = function (root, options) {
    return new Traverse(options).traverse(root);
};

var mdxProcessor = unified()
    .use(remarkParse)
    .use(remarkMdx)
    .freeze();
var AST_PROPS = ['body', 'comments', 'tokens'];
var ES_NODE_TYPES = ['export', 'import', 'jsx'];
var LOC_ERROR_PROPERTIES = ['column', 'index', 'lineNumber'];
var DEFAULT_EXTENSIONS = ['.mdx'];
var MARKDOWN_EXTENSIONS = ['.md'];
var DEFAULT_PARSER_OPTIONS = {
    comment: true,
    ecmaFeatures: {
        jsx: true,
    },
    ecmaVersion: new Date().getUTCFullYear(),
    sourceType: 'module',
    tokens: true,
    filePath: '__placeholder__.mdx',
};
var JSX_WRAPPER_START = '<$>';
var JSX_WRAPPER_END = '</$>';
var OFFSET = JSX_WRAPPER_START.length;
var Parser = /** @class */ (function () {
    function Parser() {
        // @internal
        this._options = DEFAULT_PARSER_OPTIONS;
        this.parse = this.parse.bind(this);
        this.parseForESLint = this.parseForESLint.bind(this);
    }
    Parser.prototype.normalizeJsxNode = function (node, parent, options) {
        if (options === void 0) { options = this._options; }
        var value = node.value;
        if (node.type !== 'jsx' || isComment(value)) {
            return node;
        }
        var commentContent = COMMENT_CONTENT_REGEX.exec(value);
        if (commentContent) {
            var comments_1 = [];
            var _a = node.position.start, line_1 = _a.line, column_1 = _a.column, startOffset_1 = _a.offset;
            Object.assign(node, {
                data: tslib.__assign(tslib.__assign({}, node.data), { jsxType: 'JSXElementWithHTMLComments', comments: comments_1, 
                    // jsx in paragraph is considered as plain html in mdx, what means html style comments are valid
                    // TODO: in this case, jsx style comments could be a mistake
                    inline: !!parent && parent.type !== 'root' }),
                value: value.replace(COMMENT_CONTENT_REGEX, function (matched, $0, $1, $2, offset) {
                    var endOffset = offset + matched.length;
                    var startLines = value.slice(0, offset).split('\n');
                    var endLines = value.slice(0, endOffset).split('\n');
                    var fixed = "{/" + '*'.repeat($0.length - 2) + $1 + '*'.repeat($2.length - 2) + "/}";
                    var startLineOffset = startLines.length - 1;
                    var endLineOffset = endLines.length - 1;
                    comments_1.push({
                        fixed: fixed,
                        // ! eslint ast column is 0-indexed, but unified is 1-indexed
                        loc: {
                            start: {
                                line: line_1 + startLineOffset,
                                column: last(startLines).length +
                                    (startLineOffset ? 0 : column_1 - 1),
                                offset: startOffset_1 + offset,
                            },
                            end: {
                                line: line_1 + endLineOffset,
                                column: last(endLines).length + (endLineOffset ? 0 : column_1 - 1),
                                offset: startOffset_1 + endOffset,
                            },
                        },
                        origin: matched,
                    });
                    return fixed;
                }),
            });
        }
        return this._normalizeJsxNodes(node, options);
    };
    Parser.prototype.parse = function (code, options) {
        return this.parseForESLint(code, options).ast;
    };
    Parser.prototype.parseForESLint = function (code, options) {
        var _this = this;
        var extname = path.extname(options.filePath);
        var isMdx = DEFAULT_EXTENSIONS.concat(options.extensions || []).includes(extname);
        var isMarkdown = MARKDOWN_EXTENSIONS.concat(options.markdownExtensions || []).includes(extname);
        if (!isMdx && !isMarkdown) {
            return this._eslintParse(code, options);
        }
        var root = mdxProcessor.parse(code);
        this._ast = tslib.__assign(tslib.__assign({}, normalizePosition(root.position)), { type: 'Program', sourceType: options.sourceType || 'module', body: [], comments: [], tokens: [] });
        this._services = {
            JSXElementsWithHTMLComments: [],
        };
        if (isMdx) {
            traverse(root, {
                enter: function (node, parent) {
                    if (!ES_NODE_TYPES.includes(node.type)) {
                        return;
                    }
                    var normalized = _this.normalizeJsxNode(node, parent, options);
                    normalized = Array.isArray(normalized) ? normalized : [normalized];
                    normalized.forEach(function (_node) { return _this._nodeToAst(_node, options); });
                },
            });
        }
        return {
            ast: this._ast,
            services: this._services,
        };
    };
    // @internal
    Parser.prototype._eslintParse = function (code, options) {
        if (!this._parsers || options.parser !== this._options.parser) {
            this._parsers = normalizeParser(options.parser);
        }
        /* istanbul ignore else */
        if (options.filePath && this._options !== options) {
            Object.assign(this._options, options);
        }
        var program;
        var parseError;
        for (var _i = 0, _a = this._parsers; _i < _a.length; _i++) {
            var parser_1 = _a[_i];
            try {
                program = parser_1(code, this._options);
                break;
            }
            catch (e) {
                if (!parseError) {
                    parseError = e;
                }
            }
        }
        if (!program && parseError) {
            throw parseError;
        }
        /* istanbul ignore next */
        return ('ast' in program && program.ast
            ? program
            : { ast: program });
    };
    // fix adjacent JSX nodes
    // @internal
    // eslint-disable-next-line sonarjs/cognitive-complexity
    Parser.prototype._normalizeJsxNodes = function (node, options) {
        var value = node.value;
        var program;
        try {
            // wrap into single element which is valid jsx but not valid jsx in mdx, so that it won't break on adjacent JSX nodes
            program = this._eslintParse("" + JSX_WRAPPER_START + value + JSX_WRAPPER_END, options).ast;
        }
        catch (e) {
            if (hasProperties(e, LOC_ERROR_PROPERTIES)) {
                var start = node.position.start;
                e.index += start.offset - OFFSET;
                e.column =
                    /* istanbul ignore next */
                    e.lineNumber > 1 ? e.column : e.column + start.column - OFFSET;
                e.lineNumber += start.line - 1;
                throw e;
            }
            return node;
        }
        var expression = program
            .body[0].expression;
        if (!isJsxNode(expression) || expression.children.length <= 1) {
            return node;
        }
        var _a = node.position.start, line = _a.line, offset = _a.offset;
        return expression.children.reduce(function (nodes, jsNode) {
            if (!isJsxNode(jsNode)) {
                return nodes;
            }
            var nodeStart = jsNode.start, nodeEnd = jsNode.end, 
            /* istanbul ignore next */
            _a = jsNode.loc, 
            /* istanbul ignore next */
            _b = _a === void 0 ? {
                start: { column: nodeStart, line: 1 },
                end: { column: nodeEnd, line: 1 },
            } : _a, start = _b.start, end = _b.end, 
            /* istanbul ignore next */
            _c = jsNode.range, 
            /* istanbul ignore next */
            range = _c === void 0 ? [nodeStart, nodeEnd] : _c;
            var startLine = line + start.line - 1;
            var endLine = line + end.line - 1;
            var startOffset = range[0] - OFFSET;
            var endOffset = range[1] - OFFSET;
            nodes.push({
                type: 'jsx',
                data: nodes.length ? null : node.data,
                value: value.slice(startOffset, endOffset),
                position: {
                    start: {
                        line: startLine,
                        column: line === startLine ? start.column - OFFSET : start.column,
                        offset: offset + startOffset,
                    },
                    end: {
                        line: endLine,
                        column: line === startLine ? end.column - OFFSET : end.column,
                        offset: offset + endOffset,
                    },
                },
            });
            return nodes;
        }, []);
    };
    // @internal
    Parser.prototype._nodeToAst = function (node, options) {
        var _this = this;
        if (node.data && node.data.jsxType === 'JSXElementWithHTMLComments') {
            this._services.JSXElementsWithHTMLComments.push(node);
        }
        var value = node.value;
        // fix #4
        if (isComment(value)) {
            return;
        }
        var _a = normalizePosition(node.position), loc = _a.loc, start = _a.start;
        var startLine = loc.start.line - 1; // ! line is 1-indexed, change to 0-indexed to simplify usage
        var program;
        try {
            program = this._eslintParse(value, options).ast;
        }
        catch (e) {
            /* istanbul ignore if */
            if (hasProperties(e, LOC_ERROR_PROPERTIES)) {
                // should be handled by `_normalizeJsxNodes`, just for robustness
                e.index += start;
                e.column = e.lineNumber > 1 ? e.column : e.column + loc.start.column;
                e.lineNumber += startLine;
            }
            throw e;
        }
        var offset = start - program.range[0];
        AST_PROPS.forEach(function (prop) {
            var _a;
            return (_a = _this._ast[prop]).push.apply(_a, program[prop].map(function (item) {
                return restoreNodeLocation(item, startLine, offset);
            }));
        });
    };
    return Parser;
}());
var parser = new Parser();
var parse = parser.parse, parseForESLint = parser.parseForESLint;

exports.AST_PROPS = AST_PROPS;
exports.CLOSE_TAG_REGEX = CLOSE_TAG_REGEX;
exports.COMMENT_CONTENT_REGEX = COMMENT_CONTENT_REGEX;
exports.COMMENT_REGEX = COMMENT_REGEX;
exports.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;
exports.DEFAULT_PARSER_OPTIONS = DEFAULT_PARSER_OPTIONS;
exports.ES_NODE_TYPES = ES_NODE_TYPES;
exports.FALLBACK_PARSERS = FALLBACK_PARSERS;
exports.JSX_TYPES = JSX_TYPES;
exports.LOC_ERROR_PROPERTIES = LOC_ERROR_PROPERTIES;
exports.MARKDOWN_EXTENSIONS = MARKDOWN_EXTENSIONS;
exports.OPEN_CLOSE_TAG_REGEX = OPEN_CLOSE_TAG_REGEX;
exports.OPEN_TAG_REGEX = OPEN_TAG_REGEX;
exports.Parser = Parser;
exports.SELF_CLOSING_TAG_REGEX = SELF_CLOSING_TAG_REGEX;
exports.Traverse = Traverse;
exports.closeTag = closeTag;
exports.comment = comment;
exports.commentClose = commentClose;
exports.commentOpen = commentOpen;
exports.first = first;
exports.hasProperties = hasProperties;
exports.isCloseTag = isCloseTag;
exports.isComment = isComment;
exports.isJsxNode = isJsxNode;
exports.isOpenCloseTag = isOpenCloseTag;
exports.isOpenTag = isOpenTag;
exports.isSelfClosingTag = isSelfClosingTag;
exports.last = last;
exports.mdxProcessor = mdxProcessor;
exports.normalizeParser = normalizeParser;
exports.normalizePosition = normalizePosition;
exports.openTag = openTag;
exports.parse = parse;
exports.parseForESLint = parseForESLint;
exports.parser = parser;
exports.restoreNodeLocation = restoreNodeLocation;
exports.selfClosingTag = selfClosingTag;
exports.traverse = traverse;
