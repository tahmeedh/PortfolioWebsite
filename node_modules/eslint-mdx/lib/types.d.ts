import { AST, Linter } from 'eslint';
export declare type JSXElement = import('@babel/types').JSXElement;
export declare type JSXFragment = import('@babel/types').JSXFragment;
export declare type Node = import('unist').Node;
export declare type Parent = import('unist').Parent;
export declare type Point = import('unist').Point;
export declare type JsxNode = (JSXElement | JSXFragment) & {
    range: [number, number];
};
export declare type JsxTypes = Readonly<[JSXElement['type'], JSXFragment['type']]>;
export declare type JsxType = JsxTypes[number];
export declare type Arrayable<T> = T[] | readonly T[];
export declare type ParserFn = (code: string, options: Linter.ParserOptions) => AST.Program | Linter.ESLintParseResult;
export declare type ParserConfig = {
    parseForESLint: ParserFn;
} | {
    parse: ParserFn;
};
export interface LocationError {
    column?: number;
    index?: number;
    lineNumber?: number;
}
export interface ParserOptions extends Linter.ParserOptions {
    extensions?: string | string[];
    markdownExtensions?: string | string[];
    filePath?: string;
    parser?: string | ParserConfig | ParserFn;
}
export declare type Traverser = (node: Node, parent?: Parent) => void;
export interface TraverseOptions {
    enter: Traverser;
}
export interface Comment {
    fixed: string;
    loc: {
        start: Point;
        end: Point;
    };
    origin: string;
}
//# sourceMappingURL=types.d.ts.map