/// <reference path="../typings.d.ts" />
import { __assign } from "tslib";
import { parse as esParse } from 'espree';
export var FALLBACK_PARSERS = [
    '@typescript-eslint/parser',
    'babel-eslint',
];
export var JSX_TYPES = ['JSXElement', 'JSXFragment'];
export var isJsxNode = function (node) {
    return JSX_TYPES.includes(node.type);
};
// eslint-disable-next-line sonarjs/cognitive-complexity
export var normalizeParser = function (parser) {
    if (parser) {
        if (typeof parser === 'string') {
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            parser = require(parser);
        }
        if (typeof parser === 'object') {
            parser =
                ('parseForESLint' in parser && parser.parseForESLint) ||
                    ('parse' in parser && parser.parse);
        }
        if (typeof parser !== 'function') {
            throw new TypeError("Invalid custom parser for `eslint-mdx`: " + parser);
        }
        return [parser];
    }
    var parsers = [esParse];
    // try to load FALLBACK_PARSERS automatically
    for (var _i = 0, FALLBACK_PARSERS_1 = FALLBACK_PARSERS; _i < FALLBACK_PARSERS_1.length; _i++) {
        var fallback = FALLBACK_PARSERS_1[_i];
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires
            var fallbackParser = require(fallback);
            /* istanbul ignore next */
            var parserFn = 'parseForESLint' in fallbackParser
                ? fallbackParser.parseForESLint
                : fallbackParser.parse;
            /* istanbul ignore else */
            if (parserFn) {
                parsers.unshift(parserFn);
            }
            break;
        }
        catch (e) { }
    }
    return parsers;
};
export var normalizePosition = function (position) {
    var start = position.start.offset;
    var end = position.end.offset;
    return {
        range: [start, end],
        loc: __assign({}, position),
        start: start,
        end: end,
    };
};
export function restoreNodeLocation(node, startLine, offset) {
    if (!node || !node.loc || !node.range) {
        return node;
    }
    Object.entries(node).forEach(function (_a) {
        var key = _a[0], value = _a[1];
        if (!value) {
            return;
        }
        if (Array.isArray(value)) {
            node[key] = value.map(function (child) { return restoreNodeLocation(child, startLine, offset); });
        }
        else {
            node[key] = restoreNodeLocation(value, startLine, offset);
        }
    });
    var _a = node.loc, startLoc = _a.start, endLoc = _a.end, range = node.range;
    var start = range[0] + offset;
    var end = range[1] + offset;
    return __assign(__assign({}, node), { start: start,
        end: end, range: [start, end], loc: {
            start: {
                line: startLine + startLoc.line,
                column: startLoc.column,
            },
            end: {
                line: startLine + endLoc.line,
                column: endLoc.column,
            },
        } });
}
export var first = function (items) { return items && items[0]; };
export var last = function (items) {
    return items && items[items.length - 1];
};
export var hasProperties = function (obj, properties) { return properties.every(function (property) { return property in obj; }); };
//# sourceMappingURL=helper.js.map