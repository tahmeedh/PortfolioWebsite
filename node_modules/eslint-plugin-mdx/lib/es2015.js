import { version } from 'eslint/package.json';
import { JSX_TYPES, isJsxNode, openTag, DEFAULT_EXTENSIONS, MARKDOWN_EXTENSIONS } from 'eslint-mdx';
import reactNoUnescapedEntities from 'eslint-plugin-react/lib/rules/no-unescaped-entities';
import esLintNoUnusedExpressions from 'eslint/lib/rules/no-unused-expressions';
import path from 'path';
import vfile from 'vfile';
import { cosmiconfigSync } from 'cosmiconfig';
import remarkMdx from 'remark-mdx';
import remarkParse from 'remark-parse';
import remarkStringify from 'remark-stringify';
import unified from 'unified';

const base = {
    parser: 'eslint-mdx',
    plugins: ['mdx'],
};

const getGlobals = (sources, initialGlobals = {}) => (Array.isArray(sources)
    ? sources
    : Object.keys(sources)).reduce((globals, source) => Object.assign(globals, {
    [source]: false,
}), initialGlobals);

let rebass;
try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    rebass = require('rebass');
}
catch (_a) {
    // `rebass`(or `reflexbox` actually) requires `react` as peerDependency, but not all projects using `mdx` are `React` based, so we fallback to hardcoded `rebass` Components here
    /* istanbul ignore next */
    rebass = ['Box', 'Flex', 'Text', 'Heading', 'Link', 'Button', 'Image', 'Card'];
}
const overrides = Object.assign(Object.assign({}, base), { globals: getGlobals(rebass, {
        React: false,
    }), rules: {
        'lines-between-class-members': 0,
        'react/jsx-no-undef': [
            2,
            {
                allowGlobals: true,
            },
        ],
        'react/react-in-jsx-scope': 0,
    } });

const minorVersion = +version
    .split('.')
    .slice(0, 2)
    .join('.');
const recommended = Object.assign(Object.assign({}, base), { rules: {
        'mdx/no-jsx-html-comments': 2,
        'mdx/no-unescaped-entities': 1,
        'mdx/no-unused-expressions': 2,
        'mdx/remark': 1,
        'no-unused-expressions': 0,
        'react/no-unescaped-entities': 0,
    } });
const OVERRIDES_AVAILABLE_VERSION = 6.4;
// overrides in npm pkg is supported after v6.4.0
// istanbul ignore else
if (minorVersion >= OVERRIDES_AVAILABLE_VERSION) {
    const overrides = [
        {
            files: '*.mdx',
            extends: 'plugin:mdx/overrides',
        },
    ];
    try {
        // eslint-disable-next-line node/no-extraneous-require
        require.resolve('prettier');
        // eslint-disable-next-line node/no-extraneous-require
        require.resolve('eslint-plugin-prettier');
        overrides.push({
            files: '*.md',
            rules: {
                'prettier/prettier': [
                    2,
                    {
                        parser: 'markdown',
                    },
                ],
            },
        });
    }
    catch (e) { }
    Object.assign(recommended, {
        overrides,
    });
}



var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base: base,
  overrides: overrides,
  recommended: recommended
});

const noJsxHtmlComments = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Forbid invalid html style comments in jsx block',
            category: 'SyntaxError',
            recommended: true,
        },
        messages: {
            jsxHtmlComments: 'html style comments are invalid in jsx: {{ origin }}',
        },
        fixable: 'code',
        schema: [],
    },
    create(context) {
        return {
            ExpressionStatement(node) {
                const invalidNodes = context.parserServices.JSXElementsWithHTMLComments;
                if (!JSX_TYPES.includes(node.expression.type) ||
                    node.parent.type !== 'Program' ||
                    !invalidNodes ||
                    !invalidNodes.length) {
                    return;
                }
                const invalidNode = invalidNodes.shift();
                if (invalidNode.data.inline) {
                    return;
                }
                const comments = invalidNode.data.comments;
                comments.forEach(({ fixed, loc, origin }) => context.report({
                    messageId: 'jsxHtmlComments',
                    data: {
                        origin,
                    },
                    loc,
                    node,
                    fix(fixer) {
                        return fixer.replaceTextRange([loc.start.offset, loc.end.offset], fixed);
                    },
                }));
            },
        };
    },
};

/// <reference path="../../typings.d.ts" />
// copied from `eslint-plugin-react`
const DEFAULTS = [
    {
        char: '>',
        alternatives: ['&gt;'],
    },
    {
        char: '"',
        alternatives: ['&quot;', '&ldquo;', '&#34;', '&rdquo;'],
    },
    {
        char: "'",
        alternatives: ['&apos;', '&lsquo;', '&#39;', '&rsquo;'],
    },
    {
        char: '}',
        alternatives: ['&#125;'],
    },
];
const EXPRESSION = 'Literal, JSXText';
const noUnescapedEntities = Object.assign(Object.assign({}, reactNoUnescapedEntities), { create(context) {
        const configuration = context.options[0] || {};
        const entities = configuration.forbid || DEFAULTS;
        return {
            // eslint-disable-next-line sonarjs/cognitive-complexity
            [EXPRESSION](node) {
                let { parent } = node;
                if (!isJsxNode(parent)) {
                    return;
                }
                while (parent) {
                    if (parent.parent.type === 'Program') {
                        break;
                    }
                    else {
                        parent = parent.parent;
                    }
                }
                const { start: { line: startLine, column: startColumn }, end: { line: endLine, column: endColumn }, } = node.loc;
                const { lines } = context.getSourceCode();
                let firstLineOffset = parent.loc.start.line < startLine
                    ? 0
                    : lines
                        .slice(startLine - 1, endLine)
                        .join('\n')
                        .search(openTag);
                /* istanbul ignore if */
                if (firstLineOffset < 0) {
                    // should never happen, just for robustness
                    firstLineOffset = 0;
                }
                for (let i = startLine; i <= endLine; i++) {
                    let rawLine = lines[i - 1];
                    let start = 0;
                    let end = rawLine.length;
                    if (i === startLine) {
                        start = startColumn + firstLineOffset;
                    }
                    if (i === endLine) {
                        end = endColumn;
                        if (i === startLine) {
                            end += firstLineOffset;
                        }
                    }
                    rawLine = rawLine.substring(start, end);
                    entities.forEach(entity => {
                        for (let index = 0; index < rawLine.length; index++) {
                            const char = rawLine[index];
                            if (typeof entity === 'string') {
                                if (char === entity) {
                                    context.report({
                                        loc: { line: i, column: start + index },
                                        message: `HTML entity, \`${entity}\` , must be escaped.`,
                                        node,
                                    });
                                }
                            }
                            else if (char === entity.char) {
                                context.report({
                                    loc: { line: i, column: start + index },
                                    message: `\`${entity.char}\` can be escaped with ${entity.alternatives
                                        .map(alt => '``'.split('').join(alt))
                                        .join(', ')}.`,
                                    node,
                                });
                            }
                        }
                    });
                }
            },
        };
    } });

/// <reference path="../../typings.d.ts" />
const noUnusedExpressions = Object.assign(Object.assign({}, esLintNoUnusedExpressions), { create(context) {
        const esLintRuleListener = esLintNoUnusedExpressions.create(context);
        return {
            ExpressionStatement(node) {
                if (isJsxNode(node.expression) && node.parent.type === 'Program') {
                    return;
                }
                esLintRuleListener.ExpressionStatement(node);
            },
        };
    } });

const requirePkg = (plugin, prefix, filePath) => {
    if (filePath && /^\.\.?([\\/]|$)/.test(plugin)) {
        plugin = path.resolve(path.dirname(filePath), plugin);
    }
    prefix = prefix.endsWith('-') ? prefix : prefix + '-';
    const packages = [
        plugin,
        plugin.startsWith('@')
            ? plugin.replace('/', '/' + prefix)
            : prefix + plugin,
    ];
    let error;
    for (const pkg of packages) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
            return require(pkg);
        }
        catch (err) {
            if (!error) {
                error = err;
            }
        }
    }
    throw error;
};
let searchSync;
let remarkProcessor;
const getRemarkProcessor = (searchFrom) => {
    if (!searchSync) {
        searchSync = cosmiconfigSync('remark', {
            packageProp: 'remarkConfig',
        }).search;
    }
    if (!remarkProcessor) {
        remarkProcessor = unified()
            .use(remarkParse)
            .freeze();
    }
    /* istanbul ignore next */
    const { config, filepath } = searchSync(searchFrom) || {};
    /* istanbul ignore next */
    const { plugins = [], settings } = config || {};
    try {
        // disable this rule automatically since we already have a parser option `extensions`
        // eslint-disable-next-line node/no-extraneous-require
        plugins.push([require.resolve('remark-lint-file-extension'), false]);
    }
    catch (e) {
        // just ignore if the package does not
    }
    return plugins
        .reduce((processor, pluginWithSettings) => {
        const [plugin, ...pluginSettings] = Array.isArray(pluginWithSettings)
            ? pluginWithSettings
            : [pluginWithSettings];
        return processor.use(
        /* istanbul ignore next */
        typeof plugin === 'string'
            ? requirePkg(plugin, 'remark', filepath)
            : plugin, ...pluginSettings);
    }, remarkProcessor()
        .use({ settings })
        .use(remarkStringify)
        .use(remarkMdx))
        .freeze();
};

const remark = {
    meta: {
        type: 'layout',
        docs: {
            description: 'Linter integration with remark plugins',
            category: 'Stylistic Issues',
            recommended: true,
        },
        messages: {
            remarkReport: '{{ source }}:{{ ruleId }} - {{ reason }}',
        },
        fixable: 'code',
        schema: [],
    },
    create(context) {
        const filename = context.getFilename();
        const extname = path.extname(filename);
        const sourceCode = context.getSourceCode();
        const extensions = DEFAULT_EXTENSIONS.concat(context.parserOptions.extensions || [], MARKDOWN_EXTENSIONS, context.parserOptions.markdownExtensions || []);
        return {
            Program(node) {
                /* istanbul ignore if */
                if (!extensions.includes(extname)) {
                    return;
                }
                const sourceText = sourceCode.getText(node);
                const remarkProcessor = getRemarkProcessor(filename);
                const file = remarkProcessor.processSync(vfile({
                    path: filename,
                    contents: sourceText,
                }));
                file.messages.forEach(({ source, reason, ruleId, location: { start, end } }) => context.report({
                    messageId: 'remarkReport',
                    data: {
                        reason,
                        source,
                        ruleId,
                    },
                    loc: {
                        // ! eslint ast column is 0-indexed, but unified is 1-indexed
                        start: Object.assign(Object.assign({}, start), { column: start.column - 1 }),
                        end: Object.assign(Object.assign({}, end), { column: end.column - 1 }),
                    },
                    node,
                    fix(fixer) {
                        /* istanbul ignore if */
                        if (start.offset == null) {
                            return null;
                        }
                        const range = [
                            start.offset,
                            /* istanbul ignore next */
                            end.offset == null ? start.offset + 1 : end.offset,
                        ];
                        const partialText = sourceText.slice(...range);
                        const fixed = remarkProcessor
                            .processSync(partialText)
                            .toString();
                        return fixer.replaceTextRange(range, 
                        /* istanbul ignore next */
                        partialText.endsWith('\n') ? fixed : fixed.slice(0, -1));
                    },
                }));
            },
        };
    },
};

const rules = {
    'no-jsx-html-comments': noJsxHtmlComments,
    'no-unescaped-entities': noUnescapedEntities,
    'no-unused-expressions': noUnusedExpressions,
    remark,
};

export { index as configs, getGlobals, getRemarkProcessor, noJsxHtmlComments, noUnescapedEntities, noUnusedExpressions, remark, requirePkg, rules };
