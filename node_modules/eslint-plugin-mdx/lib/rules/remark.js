import { __assign } from "tslib";
import path from 'path';
import { DEFAULT_EXTENSIONS, MARKDOWN_EXTENSIONS } from 'eslint-mdx';
import vfile from 'vfile';
import { getRemarkProcessor } from './helper';
export var remark = {
    meta: {
        type: 'layout',
        docs: {
            description: 'Linter integration with remark plugins',
            category: 'Stylistic Issues',
            recommended: true,
        },
        messages: {
            remarkReport: '{{ source }}:{{ ruleId }} - {{ reason }}',
        },
        fixable: 'code',
        schema: [],
    },
    create: function (context) {
        var filename = context.getFilename();
        var extname = path.extname(filename);
        var sourceCode = context.getSourceCode();
        var extensions = DEFAULT_EXTENSIONS.concat(context.parserOptions.extensions || [], MARKDOWN_EXTENSIONS, context.parserOptions.markdownExtensions || []);
        return {
            Program: function (node) {
                /* istanbul ignore if */
                if (!extensions.includes(extname)) {
                    return;
                }
                var sourceText = sourceCode.getText(node);
                var remarkProcessor = getRemarkProcessor(filename);
                var file = remarkProcessor.processSync(vfile({
                    path: filename,
                    contents: sourceText,
                }));
                file.messages.forEach(function (_a) {
                    var source = _a.source, reason = _a.reason, ruleId = _a.ruleId, _b = _a.location, start = _b.start, end = _b.end;
                    return context.report({
                        messageId: 'remarkReport',
                        data: {
                            reason: reason,
                            source: source,
                            ruleId: ruleId,
                        },
                        loc: {
                            // ! eslint ast column is 0-indexed, but unified is 1-indexed
                            start: __assign(__assign({}, start), { column: start.column - 1 }),
                            end: __assign(__assign({}, end), { column: end.column - 1 }),
                        },
                        node: node,
                        fix: function (fixer) {
                            /* istanbul ignore if */
                            if (start.offset == null) {
                                return null;
                            }
                            var range = [
                                start.offset,
                                /* istanbul ignore next */
                                end.offset == null ? start.offset + 1 : end.offset,
                            ];
                            var partialText = sourceText.slice.apply(sourceText, range);
                            var fixed = remarkProcessor
                                .processSync(partialText)
                                .toString();
                            return fixer.replaceTextRange(range, 
                            /* istanbul ignore next */
                            partialText.endsWith('\n') ? fixed : fixed.slice(0, -1));
                        },
                    });
                });
            },
        };
    },
};
//# sourceMappingURL=remark.js.map